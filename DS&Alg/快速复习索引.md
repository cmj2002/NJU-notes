---
Create: 2021.11.09, To "PS6-P2"
Update: 2022.01.02
---

| 项目                      | 位置 | 备注                                                         |
| ------------------------- | ---- | ------------------------------------------------------------ |
| ==主定理==                | 03   | $\Theta(n^{\log_b a}),\Theta(n^{\log_b a}\lg n),\Theta(f(n))$ |
| 归并排序                  | 03   | 思考一下 `Merge` 函数，别忘了                                |
| 双端队列（Deque）         | 02   | 记个翻译(Deque: double-ended queue)                          |
| 带哨兵的链表              | 02   | 了解概念：哨兵是头的前，尾的后                               |
| Karatsuba乘法             | 03   | $x_Ly_R+x_Ry_L=(x_L+x_R)(y_L+y_R)-x_Ly_L-x_Ry_R$             |
| Strassen矩阵乘法          | 03   | 别记，知道有这个东西即可（只需计算7个子问题                  |
| ==斯特林公式==            | 01   | $\displaystyle \lim_{n \rightarrow \infty} {\frac{n!}{\sqrt{2\pi n}\, \left(\frac{n}{e}\right)^{n}}} = 1$ |
| Reduce-and-Conquer        | 03   | 概念：不需要解决所有子问题，只需解决一个，如二分法           |
| 十字-边界递归             | 03   |                                                              |
| 堆的性质、插入和删除      | 04   | 配合PS4-P1<br>每个元素小于/大于其父元素<br>插入到堆尾，从尾部开始向上比较<br>移除根，堆尾移动到根，从根开始与子节点比较 |
| `BuildMaxHeap(data[1…n])` | 04   | 配合PS4-P1<br>从 `n/2` 开始到 `1` 结束，对每一个节点向上递归维护堆性质<br>`n/2` 到 `1` 其实是所有非叶节点，从下到上<br>维护堆性质是从上到下的，类似于删除时的处理 |
| PS3-P1(2)                 |      |                                                              |
| 选择排序、冒泡排序        | 05   | 选择排序：依次找到第 $i$ 小的元素并放置到位置 $i$            |
| 希尔排序                  | 05   | 通过**将比较的全部元素分为几个区域**来提升插入排序的性能     |
| 快速排序的期望时间复杂度  | 05   |                                                              |
| 非比较排序的时间复杂度    | 05   |                                                              |
| RndSelect期望             | 06   |                                                              |
| Median of medians         | 06   |                                                              |
| 二叉树分类                | 07   | full：0个或2个子节点<br>complete：靠左<br>perfect：全满      |
| BSTSuccessor              | 07   |                                                              |
| 搜索树的remove操作        | 07   |                                                              |
| 搜索树三大操作时间复杂度  | 07   | $O(h)$                                                       |
| 树堆                      | 07   | 插入为普通插入+旋转维护最小堆性质；删除为旋转到被删节点为叶子然后删除 |
| 红黑树定义                | 07   | 叶子和根是黑色；红色节点的子节点是黑色                       |
| 红黑树插入                | 07   |                                                              |
| 构造哈希函数-乘法         | 08   |                                                              |
| 全域散列                  | 08   | $\underset{h \in \mathcal{H}}{\operatorname{Pr}}[h(x)=h(y)] \leq \frac{1}{m}$ for all $x \neq y$ |
| PS4-P5                    |      |                                                              |
| PS4-P8                    |      |                                                              |
| PS5-P6                    |      | 对于搜索树，[morris遍历](https://zhuanlan.zhihu.com/p/101321696)的核心在于让无右节点的节点的右指针指向树中大于其的最小元素 |
| PS6-P2                    |      | 问人                                                         |
| Protential Method         | 09   |                                                              |
| 把10扫一眼就行            | 10   | 链表、有根树结构，union by rank, union by height             |
| 邻接表和邻接矩阵的利弊    | 11   | 邻接矩阵查询 “$u,v$ 是否是邻居” 比较快，查询某节点的一个、多个、所有邻居慢。<br>邻接表相反<br>选择时考虑频繁操作（时间复杂度）、矩阵稀疏程度（空间复杂度） |
| BFS，DFS                  | 11   | 邻接表下时间复杂度都是 $O(|V|+|E|)$，记住三状态转换，DFS中的时间 |
| DFS的四种边               | 11   | 这个要回去看                                                 |
| 拓扑排序                  | 12   | 生成拓扑排序使用DFS的 $d,f$；拓扑排序的意义                  |
| SCC的两种算法             | 12   |                                                              |
| 最小生成树                | 13   | 边权之和最小的生成树( 包含 $V$ 中所有节点，边集 $T$ 是 $E$ 的子集的树 ) |
| 最小生成树三种算法        | 13   | 都是 $m\log n$                                               |
| 贪心算法的成立条件        | 14   | 最优子结构（最优解包含子结构的最优解）、贪心选择性质（贪心的选择是最优的） |
| Huffman编码               | 14   | 注意只有叶子节点能放元素                                     |
| SSSP算法                  | 15   | BellmanFord（n-1次更新所有距离），Dijkstra（最小堆）         |
| SSSP，APSP算法表          | 16   |                                                              |
| JohnsonAPSP               | 16   | Create H=(V+{z},E+{(z,v)\|v∈V}) with w(z,v)=0<br>Bellman-FordSSSP(H,z) to obtain distH |
| 递归APSP                  | 16   | $(1,l-1),(l/2,l/2),x_r$                                      |
| 动态规划                  | 17   | 空间换时间，储存所有子问题的解                               |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |
|                           |      |                                                              |

搜索树：$O(h)$

树堆：期望上 $h=O(\log n)$

红黑树：最坏情况 $h=O(\log n)$

