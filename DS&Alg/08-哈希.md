# 08 哈希

hashing，又叫散列

## 思想

### 直接寻址表(direct-address tables)

假设要储存非负整数 $\{0,1,\cdots ,m-1\}$

申请规模为 $m$ 的存储空间，将每个数存入对应的存储空间

可以在 $O(1)$ 内完成查找，插入，删除

### 用直接寻址表储存一般元素

问题：

* 储存的不是正整数
* 储存的元素可能有一个极大的值域

解决：

* 在计算机中所有东西都是二进制数
* 需要找到一个映射 $h$（哈希函数），把一个元素从值域映射到集合 $[m]$ 上
  * $h(k)$ 决定了 $k$ 所存储的位置
  * $m$ 远小于值域，但是和需要储存的元素数量大致相当

### 哈希函数

需要的性质：

* 均匀（随机）地返回 $[0,m-1]$ 中的一个整数
* 对相同的参数返回相同的结果

#### 哈希碰撞

哈希函数不能唯一地代表元素：哈希函数的值域要小于元素的值域

$k_1,k_2$ 满足 $h(k_1)=h(k_2)$ 时称为哈希冲突或哈希碰撞（hash collision)

**解决办法**：每个哈希值对应一个链表的头指针，链表储存同一个哈希值的所有元素（Hashing with chaining）

## hashing with chaining

搜索：

* `Search(k)` ，`k` 是一个元素的值
* 时间复杂度：
  * 如果插入的元素是均匀分布的（即生成的哈希值是随机分布的，称为 Simple Uniform Hashing）
  * 定义 load factor $\alpha=n/m$，这是每个哈希值的链表的期望元素个数
  * 时间复杂度 $\Theta(1+\alpha)$

删除：

* `Remove(x)` ，`x` 是指向该元素的指针
* $O(1)$

插入：

* `Insert(x)`，`x` 是指向该元素的指针
* $O(1)$

## 构造哈希函数

### 主要方法

* 取模
* 乘法
  * 假设输入的长度最长为 $w$
  * 固定 $m=2^r,r\leq w$
  * 固定整数 $A,0<A<2^w$
  * 哈希函数：$((A\cdot k)\mod{2^w})>>(w-r)$

### Universal Hashing

对于确定的哈希函数，一定可以构造一组坏的输入，哈希值相同

所以在创建哈希表时随机选择一个哈希函数

一个哈希函数的集合是 universal 的，当且仅当它满足：

$\underset{h \in \mathcal{H}}{\operatorname{Pr}}[h(x)=h(y)] \leq \frac{1}{m}$ for all $x \neq y$

<img src="08 哈希.assets/image-20211028110211590.png" alt="image-20211028110211590" style="zoom: 50%;" />

### 构建 universal hash family

一种典型的 universal hash family（by Carter and Wegman in 1977）

* 找到输入值域的一个上界 $p$
* $\Z_p=\{0,1,2,\cdots,p-1\},\Z_p^*=\{1,2,\cdots,p-1\}$
* $h_{ab}(k)=((ak+b)\mod p)\mod m$
* $\mathcal{H}_{pm}=\{h_{ab}|a\in\Z_p^*\; and\;b\in \Z_p\}$

<img src="08 哈希.assets/image-20211028112816400.png" alt="image-20211028112816400" style="zoom:80%;" />

<img src="08 哈希.assets/image-20211028112941247.png" alt="image-20211028112941247" style="zoom:50%;" />

<img src="08 哈希.assets/image-20211028113003177.png" alt="image-20211028113003177" style="zoom:80%;" />

## 开放寻址（Open Addressing）

处理哈希碰撞的另一种方法，放弃之前链表的做法

